stages:
  - test
  - build
  - deploy

variables:
  # Docker-in-Docker configuration
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: 1
  
  # Image names
  DOCKER_IMAGE_BACKEND: $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
  DOCKER_IMAGE_FRONTEND: $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
  DOCKER_LATEST_BACKEND: $CI_REGISTRY_IMAGE/backend:latest
  DOCKER_LATEST_FRONTEND: $CI_REGISTRY_IMAGE/frontend:latest

# Test backend
test-backend:
  stage: test
  image: python:3.9-slim
  before_script:
    - cd backend
    - pip install -r requirements.txt
  script:
    - python -c "import sys; print('Python version:', sys.version)"
    - python app.py init  # Test database initialization
    - echo "Backend tests completed successfully"
  only:
    - main
    - merge_requests

# Test frontend
test-frontend:
  stage: test
  image: node:16-alpine
  before_script:
    - cd frontend
    - npm ci --prefer-offline --no-audit
  script:
    - CI=false npm run build  # Don't treat warnings as errors
    - echo "Frontend build completed successfully"
  only:
    - main
    - merge_requests

# Build backend Docker image
build-backend:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - echo "Waiting for Docker daemon..."
    - until docker info; do sleep 1; done
    - echo "Docker daemon is ready"
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "Building backend Docker image..."
    - docker build -t $DOCKER_IMAGE_BACKEND -t $DOCKER_LATEST_BACKEND -f docker/backend.Dockerfile .
    - echo "Pushing backend images..."
    - docker push $DOCKER_IMAGE_BACKEND
    - docker push $DOCKER_LATEST_BACKEND
  only:
    - main

# Build frontend Docker image
build-frontend:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - echo "Waiting for Docker daemon..."
    - until docker info; do sleep 1; done
    - echo "Docker daemon is ready"
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "Building frontend Docker image..."
    - docker build -t $DOCKER_IMAGE_FRONTEND -t $DOCKER_LATEST_FRONTEND -f docker/frontend.Dockerfile .
    - echo "Pushing frontend images..."
    - docker push $DOCKER_IMAGE_FRONTEND
    - docker push $DOCKER_LATEST_FRONTEND
  only:
    - main

# Deploy to university VM
deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client git
    - eval $(ssh-agent -s)
    # Create temporary file for SSH key to avoid stdin issues
    - echo "$SSH_PRIVATE_KEY" > /tmp/ssh_key
    - chmod 600 /tmp/ssh_key
    - ssh-add /tmp/ssh_key
    - rm /tmp/ssh_key
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VM_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "Starting deployment to $VM_USER@$VM_HOST"
    - |
      ssh -o StrictHostKeyChecking=no $VM_USER@$VM_HOST << 'EOF'
        set -e
        echo "Connected to VM successfully"
        
        # Navigate to project directory
        cd /var/www/cluster-usage-dashboard || exit 1
        echo "Changed to project directory"
        
        # Pull latest code
        git fetch origin main
        git reset --hard origin/main
        echo "Updated code from repository"
        
        # Stop current containers
        docker-compose -f docker-compose.prod.yml down || true
        echo "Stopped existing containers"
        
        # Start with new images (build locally for now)
        docker-compose -f docker-compose.prod.yml up --build -d
        echo "Started new containers"
        
        # Clean up old images
        docker image prune -f
        echo "Cleaned up old Docker images"
        
        # Show status
        echo "Final container status:"
        docker-compose -f docker-compose.prod.yml ps
      EOF
  only:
    - main
  needs: ["build-backend", "build-frontend"]

# Test SSH connection (manual job for debugging)
test-ssh:
  stage: test
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" > /tmp/ssh_key
    - chmod 600 /tmp/ssh_key
    - ssh-add /tmp/ssh_key
    - rm /tmp/ssh_key
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VM_HOST >> ~/.ssh/known_hosts
  script:
    - echo "Testing SSH connection to $VM_USER@$VM_HOST"
    - ssh -o StrictHostKeyChecking=no $VM_USER@$VM_HOST "echo 'SSH connection successful'; whoami; pwd"
  when: manual
  allow_failure: true

# Deploy to university VM
deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client docker-compose git
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VM_HOST >> ~/.ssh/known_hosts
  script:
    - |
      ssh $VM_USER@$VM_HOST "
        # Navigate to project directory
        cd /var/www/cluster-usage-dashboard || exit 1
        
        # Pull latest code
        git fetch origin main
        git reset --hard origin/main
        
        # Login to GitLab container registry
        echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
        
        # Pull latest images
        docker pull $DOCKER_LATEST_BACKEND
        docker pull $DOCKER_LATEST_FRONTEND
        
        # Stop current containers
        docker-compose -f docker-compose.prod.yml down
        
        # Start with new images
        docker-compose -f docker-compose.prod.yml up -d
        
        # Clean up old images
        docker image prune -f
        
        # Show status
        docker-compose -f docker-compose.prod.yml ps
      "
  only:
    - main
  needs: ["build-backend", "build-frontend"]